# Linux 系统编程基础

## 总览

- [1 参数列表](#1)
    - [1.1 Linux 命令行规范](#1.1)
    - [1.2 程序访问参数列表的方法](#1.2)
    - [1.3 代码](#1.3)
- [2 选项数组](#2)
    - [2.1 optstring 定义规则](#2.1)
    - [2.2 getopt](#2.2)
    - [2.3 getopt_long](#2.3)

<h2 id="1">1 参数列表</h2>

<h3 id="1.1">1.1 Linux 命令行规范</h3>

- 短参数：以单横开头，后跟单一字符，例：ls -h
- 长参数：以双横开头，后跟字符串，例：ls --help

<h3 id="1.2">1.2 程序访问参数列表的方法</h3>

- 主函数的参数 argc 和 argv
- 程序接受命令行的输入参数，并解释之

<h3 id ="1.3">1.3 代码</h3>

```c
//main.cpp
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
    for (int i = 0; i < argc; i++) {
        cout << i << ":" << argv[i] << endl;
    }
    return 0;
}
```

```bash
g++ main.cpp && ./a.out -c 200 -n 100000
``` 

```bash
0:./a.out
1:-c
2:200
3:-n
4:100000
```

<h2 id="2">2 选项数组</h2>

当需要对命令行参数进行处理时，如果参数个数很多，按照顺序一个个定义参数含义很容易造成混乱，同时如果只按顺序处理参数，那么一些可选参数的功能就很难实现。

在 Linux 中，我们可以使用 getopt、getopt_long、getopt_long_only 来解析命令行选项参数。

```c
#include <unistd.h>

extern char *optarg;//选项参数的指针
extern int optind,//下次调用 getopt 时，从 optind 存储的位置开始检查选项
           opterr,//设置 opterr = 0 时，getopt 不向 strerr 输出错误信息
           optopt;//选项不在 optstring 中，或缺少必要的参数时，该选项存储在 optopt 中，getopt 返回 ?

//返回选项名。如果查不到 optstring 中的选项时，返回 -1
int getopt(int argc, char * const argv[],
           const char *optstring);

#include <getopt.h>

int getopt_long(int argc, char * const argv[],
                const char *optstring,
                const struct option *longopts, int *longindex);

int getopt_long_only(int argc, char * const argv[],
                     const char *optstring,
                     const struct option *longopts, int *longindex);
```

<h3 id="2.1">2.1 optstring 定义规则</h3>

- `c`：使用 -c，没有参数
- `c:`：使用 -c 200 或 -c200，单冒号表示选项含有参数，选项和参数可以有空格分隔或者不分隔
- `c::`：使用 -c200，双冒号表示选项含有参数，选项和参数不分隔

<h3 id="2.2">2.2 getopt</h3>

```c
//main.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char *argv[])
{
    const char *optstring = "c:n:p:vh";
    const char *version   = "0.1";
    int opt, concurrency = 1, requests = 10, port = 80;
    char usage[128];
    sprintf(usage, "Usage: %s [-c concurrency] [-n requests] [-p port] [-vh] url\n", argv[0]);
    while (-1 != (opt = getopt(argc, argv, optstring))) {
        switch (opt) {
            case 'c':
                concurrency = atoi(optarg);//字符串转成整形
                break;
            case 'n':
                requests = atoi(optarg);
                break;
            case 'p':
                port = atoi(optarg);
                break;
            case 'v':
                printf("Version: %s\n", version);
                exit(EXIT_SUCCESS);
            case 'h':
            default:/* '?' */
                fprintf(stderr, usage);
                exit(EXIT_FAILURE);
        }
    }
    if (optind >= argc) {
        fprintf(stderr, "Excepted argument after options\n%s", usage); 
        exit(EXIT_FAILURE);
    }
    printf("concurrency=%d; requests=%d; port=%d; optind=%d\n", concurrency, requests, port, optind);
    printf("url argument = %s\n", argv[optind]);
    exit(EXIT_SUCCESS);
}
```

```bash
gcc main.c && ./a.out -c 100 -n10000 localhost
concurrency=100; requests=10000; port=80; optind=4
url argument = localhost
```

<h3 id="2.3">2.3 getopt_long</h3>
