# 进程编程

## 目录

- [1 进程基本概念](#1)
- [2 信号](#2)

<h2 id="1">进程基本概念</h2>

进程（process）的定义：

- 进程是描述程序执行过程和资源共享的基本单位
- 主要目的：控制和协调程序的执行

进程相关函数：

- 用户和组 ID 函数
- 创建进程：system()、fork()、exec()
- 终止进程：kill()
- 等待进程终止：wait()、waitpid()

进程组：

- 定义：由一个或多个相关联的进程组成，目的是为了作业控制
- 进程组的主要特征：信号可以发送给进程组中的所有进程，并使该进程组中的所有子进程终止、停止或继续运行
- 每个进程都属于某个进程组

进程组函数

- 获取进程组 ID：pid_t getpgid(pid_t pid);
  - 返回 pid 进程的进程组 ID；若 pid 为 0，则返回当前进程的进程组 ID；出错时返回 -1，并设 errno 值
- 设置进程组 ID：int setpgid(pid_t pid, pid_t pgid);
  - 若 pid 为0，则使用调用者 PID；若 pgid 为 0，则将 pid 进程的进程 PID 设为 进程组 ID；成功时返回 0，出错时返回 -1，并设 errno 值

会话（session）

- 会话为一个或多个进程组的集合，包括登录用户的全部活动，并具有一个控制终端
- 登录进程为每个用户创建一个会话，用户登录 shell 进程成为会话首领，其 PID 设为会话 ID
- 非会话首领进程通过调用 setsid() 函数创建新会话，并成为首领

进程组函数

- 获取会话ID：pid_t getsid(pid_t pid);
  - 返回 pid 进程的会话 ID；若 pid 为 0，则返回当前进程的会话 ID；成功时返回会话 ID，出错时返回 -1，并设 errno 值
- 设置会话 ID：pid_t setsid();
  - 成功时返回新创建的会话 ID，出错时返回 -1，并设 errno 值

<h2 id="2">2 信号</h2>

信号（signal）：进程通讯机制

- 信号是发送给进程的特殊异步消息
- 当进程接收到信息时立即处理，此时并不需要完成当前函数调用甚至当前代码行
- Linux 系统中有多种信号，各具有不同的意义；系统以数字表示不同的信号，程序一般以名称引用之

系统信号：

- 缺省处理逻辑：终止进程，生成内核转储文件
- 使用 kill -l 命令查看操作系统支持的信号列表，不同的系统可能有所不同

系统信号表：

<table>
  <tr><th align="center">信号</th><th align="center">值</th><th align="center">缺省动作</th><th>含义</th></tr>
  <tr><td align="center">SIGHUP</td><td align="center">1</td><td align="center">终止进程</td><td>终端的挂断或进程死亡</td></tr>
  <tr><td align="center">SIGINT</td><td align="center">2</td><td align="center">终止进程</td><td>来自键盘的中断信号，通常为 Ctrl + C</td></tr>
  <tr><td align="center">SIGQUIT</td><td align="center">3</td><td align="center">内核转储</td><td>来自键盘的离开信号</td></tr>
  <tr><td align="center">SIGILL</td><td align="center">4</td><td align="center">内核转储</td><td>非法指令</td></tr>
  <tr><td align="center">SIGTRAP</td><td align="center">5</td><td align="center">内核转储</td><td>断点或其他陷阱指令，用于调试器</td></tr>
  <tr><td align="center">SIGABRT</td><td align="center">6</td><td align="center">内核转储</td><td>来自 abort 的异常信号</td></tr>
  <tr><td align="center">SIGBUS</td><td align="center">7</td><td align="center">内核转储</td><td>总线错误（内存访问错误）</td></tr>
  <tr><td align="center">SIGFPE</td><td align="center">8</td><td align="center">内核转储</td><td>浮点异常</td></tr>
  <tr><td align="center">SIGKILL</td><td align="center">9</td><td align="center">终止进程</td><td>杀死进程</td></tr>
  <tr><td align="center">SIGUSR1</td><td align="center">10</td><td align="center">终止进程</td><td>用户自定义信号1</td></tr>
  <tr><td align="center">SIGSEGV</td><td align="center">11</td><td align="center">内核转储</td><td>段非法错误（内存访问无效）</td></tr>
  <tr><td align="center">SIGUSR2</td><td align="center">12</td><td align="center">终止进程</td><td>用户自定义信号2</td></tr>
  <tr><td align="center">SIGPIPE</td><td align="center">13</td><td align="center">终止进程</td><td>管道损坏：向一个没有读进程的管道写数据</td></tr>
  <tr><td align="center">SIGALRM</td><td align="center">14</td><td align="center">终止进程</td><td>计时器定时信号</td></tr>
  <tr><td align="center">SIGTERM</td><td align="center">15</td><td align="center">终止进程</td><td>进程终止信号</td></tr>
  <tr><td align="center">SIGSTKFLT</td><td align="center">16</td><td align="center">终止进程</td><td>协处理器堆栈错误（不使用）</td></tr>
  <tr><td align="center">SIGCHLD</td><td align="center">17</td><td align="center">忽略</td><td>子进程停止或终止</td></tr>
  <tr><td align="center">SIGCONT</td><td align="center">18</td><td align="center">忽略</td><td>如果停止，继续执行</td></tr>
  <tr><td align="center">SIGSTOP</td><td align="center">19</td><td align="center">停止进程</td><td>非来自终端的停止信号</td></tr>
  <tr><td align="center">SIGTSTP</td><td align="center">20</td><td align="center">停止进程</td><td>来自终端的停止信号，通常为 Ctrl + Z</td></tr>
  <tr><td align="center">SIGTTIN</td><td align="center">21</td><td align="center">停止进程</td><td>后台进程读取端</td></tr>
  <tr><td align="center">SIGTTOU</td><td align="center">22</td><td align="center">停止进程</td><td>后台进程写终端</td></tr>
  <tr><td align="center">SIGURG</td><td align="center">23</td><td align="center">忽略</td><td>有紧急数据到达套接字信号</td></tr>
  <tr><td align="center">SIGXCPU</td><td align="center">24</td><td align="center">内核转储</td><td>超过CPU时限</td></tr>
  <tr><td align="center">SIGXFSZ</td><td align="center">25</td><td align="center">内核转储</td><td>超过文件长度限制</td></tr>
  <tr><td align="center">SIGVTALRM</td><td align="center">26</td><td align="center">终止进程</td><td>虚拟计数器定时信号（进程占用 CPU 时间）</td></tr>
  <tr><td align="center">SIGPROF</td><td align="center">27</td><td align="center">终止进程</td><td>计时器定时信号（程序占用 CPU 时间和系统调度时间）</td></tr>
  <tr><td align="center">SIGWINCH</td><td align="center">28</td><td align="center">忽略</td><td>窗口大小改变</td></tr>
  <tr><td align="center">SIGIO</td><td align="center">29</td><td align="center">终止进程</td><td>描述符上可进行I/0操作</td></tr>
  <tr><td align="center">SIGPWR</td><td align="center">30</td><td align="center">终止进程</td><td>电力故障</td></tr>
  <tr><td align="center">SIGSYS</td><td align="center">31</td><td align="center">内核转储</td><td>非法系统调用</td></tr>
</table>

进程间发送的信号：

- SIGTERM、SIGKILL：终止进程信号，前者是请求（接收信号的进程可以忽略之），后者是强制
- SIGUSR1、SIGUSR2：用户自定义信号，可用于向进程发送命令

信号处理：

- 进程接收到信号后，根据信号配置进行处理
- 缺省配置：在程序没有处理时，确定信号该如何处理
- 程序处理信号的方式：按照信号处理例程的函数指针类型定义一个函数，然后调用

sigaction() 函数：设置信号配置

- 原型：int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
- signum 为信号编号，act 和 oldact 分别为指向信号结构体 struct sigaction 的指针，前者为新配置，后者为需要保存的老配置

信号结构体 struct sigaction

- 最重要的成员为 sa_handler，其取值为 SIG_DFL（使用信号缺省配置）、SIG_IGN（忽略该信号）或指向信号处理例程的函数指针（以信号编号为参数，无返回值）

处理信号时的注意事项

- 信号时异步操作，当处理信号时，主程序非常脆弱
- 信号处理例程应尽可能短小，它甚至有可能会被新信号所中断
- 尽量不要在信号处理例程中实施 I/O 操作，也不要频繁调用系统函数或库函数
- 在信号处理例程中进行复杂的赋值操作也是危险的，它可能不是原子操作，因而有可能在执行期间被中断
- 如果需要赋值，使用 sig_atomic_t 类型的全局变量（在 Linux 中等价于 int，亦允许整数或指针赋值，更大尺寸数据不允许）
